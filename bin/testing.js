// Generated by CoffeeScript 1.3.3
(function() {
  var appendScript, compare, fetchResults,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window._bTestResults = null;

  compare = function(e1, e2) {
    var i, k, key, keys, v, _i, _j, _len, _ref;
    if (e1 === e2) {
      return true;
    }
    if (e1 instanceof Array || e2 instanceof Array) {
      if (!(e1 instanceof Array && e2 instanceof Array)) {
        return false;
      }
      if (e1.length !== e2.length) {
        return false;
      }
      for (i = _i = 0, _ref = e1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (!compare(e1[i], e2[i])) {
          return false;
        }
      }
      return true;
    }
    if (typeof e1 === 'object' || typeof e2 === 'object') {
      if (!(typeof e1 === 'object' && typeof e2 === 'object')) {
        return false;
      }
      keys = [
        (function() {
          var _results;
          _results = [];
          for (k in e1) {
            v = e1[k];
            _results.push(k);
          }
          return _results;
        })()
      ];
      if (!compare(keys, [
        (function() {
          var _results;
          _results = [];
          for (k in e2) {
            v = e2[k];
            _results.push(k);
          }
          return _results;
        })()
      ])) {
        return false;
      }
      for (_j = 0, _len = keys.length; _j < _len; _j++) {
        key = keys[_j];
        if (!compare(e1[key], e2[key])) {
          return false;
        }
      }
      return true;
    }
    return false;
  };

  QUnit.config.autostart = false;

  $(function() {
    var j, json, t, _fn, _i, _len, _ref;
    _ref = ((function() {
      var _results;
      _results = [];
      for (t in testData) {
        j = testData[t];
        _results.push(t);
      }
      return _results;
    })()).sort();
    _fn = function(t, json) {
      return test(t, function() {
        var bjson, json2;
        bjson = BJSON.serialize(json);
        json2 = BJSON.parse(bjson);
        return ok(compare(json, json2), "Original JSON object matches serialized and parsed JSON object");
      });
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      json = testData[t];
      _fn(t, json);
    }
    $("#run-tests").click(function() {
      return QUnit.start();
    });
    $("#show-qunit").click(function() {
      $("#qunit").show();
      return $("#show-qunit").hide();
    });
    return fetchResults();
  });

  QUnit.testDone(function(_arg) {
    var failed, name, passed, total;
    name = _arg.name, failed = _arg.failed, passed = _arg.passed, total = _arg.total;
    return window._bTestResults[name] = failed === 0 && passed === total ? 1 : 0;
  });

  QUnit.begin(function() {
    return window._bTestResults = {};
  });

  QUnit.done(function() {
    if (typeof _bTestResults !== "undefined" && _bTestResults !== null) {
      appendScript("http://www.browserscope.org/user/beacon/" + _bTestKey);
    }
    $("#show-qunit").show();
    return $("#run-test-msg").hide();
  });

  appendScript = function(src) {
    var firstScript, newScript;
    firstScript = document.getElementsByTagName('script')[0];
    newScript = document.createElement('script');
    newScript.src = src;
    return firstScript.parentNode.insertBefore(newScript, firstScript);
  };

  fetchResults = function(v) {
    if (v == null) {
      v = 1;
    }
    return appendScript("http://www.browserscope.org/user/tests/table/" + _bTestKey + "?v=" + v + "&o=json&callback=_fetchedResults");
  };

  this._fetchedResults = function(_arg) {
    var allTests, bad, browser, category_name, count, data, inconsistent, result, results, succ, summary_score, supported, table, test, tests, tr, unknown, v, _i, _len, _ref, _ref1, _ref2;
    category_name = _arg.category_name, v = _arg.v, results = _arg.results;
    allTests = [];
    for (browser in results) {
      tests = results[browser].results;
      for (test in tests) {
        result = tests[test].result;
        if (__indexOf.call(allTests, test) < 0) {
          allTests.push(test);
        }
      }
    }
    allTests.sort();
    succ = function(result, inconsistent) {
      if (result) {
        return "<span class='label icon-ok'> Passed</span>";
      } else if (inconsistent) {
        return "<span class='label label-warning icon-remove'> Inconsistent</span>";
      } else {
        return "<span class='label label-inverse icon-remove'> Failed</span>";
      }
    };
    table = $("<table class='table table-hover'></table>");
    for (browser in results) {
      _ref = results[browser], count = _ref.count, summary_score = _ref.summary_score, tests = _ref.results;
      supported = true;
      inconsistent = false;
      data = "Results from " + count + " runs with a success rate of " + summary_score + "%";
      data += "<div style='height: 500px; overflow: auto;'><table class='table table-condensed'>";
      for (_i = 0, _len = allTests.length; _i < _len; _i++) {
        test = allTests[_i];
        bad = ("" + (((_ref1 = tests[test]) != null ? _ref1.result : void 0) || "0")) !== "1";
        supported = supported && !bad;
        unknown = bad && (!(tests[test] != null) || ((_ref2 = tests[test]) != null ? _ref2.result : void 0) !== "0");
        if (unknown) {
          inconsistent = true;
        }
        data += "<tr><th>" + test + "</th><td>" + (succ(!bad, unknown)) + "</td></tr>";
      }
      data += "</table></div>";
      tr = $("<tr style='cursor: pointer;'><th>" + browser + "</th><td>" + (succ(supported, inconsistent)) + "</td></tr>");
      table.append(tr);
      tr.attr({
        tabindex: -1
      });
      tr.css("outline", "none");
      tr.popover({
        trigger: 'focus',
        html: true,
        placement: 'left',
        title: "Results for " + browser,
        content: data
      });
    }
    $("#results").html("");
    return $("#results").append(table);
  };

}).call(this);
